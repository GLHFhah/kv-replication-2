VersionVector используем для операций записи.

compare_vectors - сравнивает два вектора версий и в дальнейшем используем для слияния в merge_entries

merge_entries - сливает записи

merge_cart_values - сливает записи cart

self._pending_ops = {} Ожидающие операции GET/PUT
self._pending_forwards = {} Ожидающие пересланные PUT

_get_preference_list - используем для Sloppy Quorum - начинаем с первичной реплики ключа и идем по кольцу.


Обработка локальных сообщений

При Get - сохраняем состояние операции, отправляем READ первым 3 узлам (основным репликам) и устанавливаем таймер для Sloppy Quorum.

При Put - если я являюсь основной репликой ключа, то координируем запись. Иначе пересылаем запрос одной из реплик (включая кол-во испробованных реплик)



Координация записи. 

Создаем новый вектор версий, используем поколения (инкрементируем свой счетчик).

Отправляем write первым 3 узлам preference list (репликам), не забываем указать, пришел ли запрос от локального клиента или от узла

Сетевые сообщения

READ, отправляем все версии ключа, сохраняем состояние операции, отправляем READ_RESP

READ_RESP, сохраняем ответ от этого узла, проверяем достижение кворума, если достигли, то завершаем операцию

WRITE, оставляем версии, которые не являются предками новой версии, проверяем, не устарела ли новая версия, если нет, то добавляем ее в список версий.
если мы не являемся репликой ключа,то пересылаем сообщение им (hinted handoff)

WRITE_RESP, сохраняем ответ от этого узла, проверяем достижение кворума, если достигли, то завершаем операцию

FORWARD_PUT, - просто координируем запись
FORWARD_PUT_RESP, - отправляем ответ локальному клиенту

Завершение операций. 
complete_get
Удаляет операцию из списка ожидающих и отменяет таймер, поскольку ожидание ответов больше не требуется.
Сбор данных. Объединяет все записи, полученные от разных реплик, в один общий список.
Сливаем эти версии.
Read Repair. Отправляем актуальные версии всем репликам, которые ответили.
Обработка корзины. Если ключ начинается с префикса CART, то вместо возврата нескольких версий, просто сливаем.
Отправка ответа. Формируем и отправляем ответ локальному клиенту, содержащий список значений и объединённый контекст.

complete_put
Аналогичное удаление операции.
Определение текущего состояния. Получает текущие данные из локального хранилища координатора и добавляет к ним только что записанное значение с новым вектором версий.
Сливаем эти версии.
Обработка корзины.
Отправка ответа. В зависимости от источника запроса отправляет ответ либо локальному клиенту, либо узлу, который переслал запрос.


Ну осталось сказать об обработке таймеров.
Таймеры с префиксом "hh1_" отвечают за механизм Hinted Handoff. Когда узел, не являющийся основной репликой для ключа, получает данные, 
он должен передать их настоящим репликам. Первая попытка передачи происходит сразу при получении данных. 
Если основные реплики были недоступны в тот момент, таймер срабатывает через несколько секунд и запускает повторную попытку передачи.
При срабатывании такого таймера узел проверяет, есть ли у него данные для указанного ключа. Если данные всё ещё хранятся локально, значит, передача не состоялась ранее. 
Узел определяет список основных реплик для этого ключа и отправляет им все хранящиеся версии данных. 
Это гарантирует, что данные в конечном итоге попадут на нужные реплики, даже если те были временно недоступны.
Таймеры, соответствующие идентификаторам операций, отвечают за  Sloppy Quorum.
Когда операция чтения или записи не получает достаточного количества ответов от основных реплик в отведённое время, 
система расширяет круг опрашиваемых узлов.
Для операций GET: если количество полученных ответов меньше требуемого кворума, 
координатор отправляет запрос чтения следующему узлу из списка. Затем устанавливается новый таймер для ожидания этого ответа. 
Процесс повторяется, пока не будет достигнут кворум или не закончится список узлов.
Для операций PUT: аналогично, если количество подтверждений записи недостаточно, координатор отправляет запись 
следующему узлу из списка предпочтений и устанавливает новый таймер.
Для переадресованных запросов: если узел переслал запрос PUT другому узлу для координации и не получил ответа, 
таймер запускает повторную попытку. Запрос пересылается следующему кандидату из списка реплик. 

Вместо стратегии Last Write Wins, которая опирается на физическое время и может приводить к потере данных из-за рассинхронизации часов, 
используются векторы версий. Вектор версий представляет собой словарь, где ключом является идентификатор узла-координатора, 
а значением — счётчик операций записи, выполненных этим узлом.
При каждой операции записи координатор увеличивает свой счётчик в векторе версий. Это позволяет отслеживать связи между операциями: если все компоненты одного вектора меньше или равны соответствующим компонентам другого, 
то первая версия является предком второй и может быть безопасно удалена. Если же векторы несравнимы (один больше по одним компонентам, другой — по другим), 
версии считаются конкурентными и обе сохраняются.
Координация записи
Операции записи координируются одной из реплик ключа. Когда клиент отправляет запрос PUT на узел, не являющийся репликой для данного ключа, запрос перенаправляется одной из реплик. 
Выбранная реплика становится координатором: она генерирует новый вектор версий, увеличивая свой счётчик, и рассылает данные всем репликам ключа.
Обработка запроса GET
При получении запроса GET узел определяет список реплик для запрошенного ключа и отправляет им запросы чтения. Узел ожидает ответов от кворума. 
После достижения кворума все полученные записи объединяются: удаляются дубликаты и устаревшие версии. 
Дополнительно выполняется операция Read Repair: актуальные версии данных отправляются всем репликам, 
которые ответили на запрос. Это позволяет синхронизировать реплики.
Обработка запроса PUT
При получении запроса PUT координатор формирует новый вектор версий на основе контекста, переданного клиентом, увеличивая свой счётчик. 
Затем данные с новым вектором версий рассылаются всем репликам. Координатор ожидает подтверждений от заданного количества реплик (кворум записи). 
После достижения кворума операция считается успешной.
При получении данных реплика сравнивает новую версию с уже хранящимися. Устаревшие версии удаляются, а конкурентные сохраняются вместе с новой.
Sloppy Quorum
Для обеспечения доступности при временной недоступности части узлов реализован механизм Sloppy Quorum. Если в течение заданного времени не удаётся получить достаточное количество 
ответов от основных реплик, запросы отправляются дополнительным узлам из pref_list.
Hinted Handoff
Когда данные записываются на узел, не являющийся основной репликой для ключа, этот узел должен передать данные настоящим репликам. 
Передача выполняется немедленно после получения данных. Если основные реплики недоступны в момент первой попытки, через несколько секунд запускается 
повторная попытка передачи.